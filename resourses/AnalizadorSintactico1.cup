package codigo3d.backend.analizadores;

import java_cup.runtime.*;
import codigo3d.backend.manejadores.*;
import codigo3d.backend.objetos.*;
import java.util.LinkedList;

parser code {:

	private ManejadorParser mp = null;

	// Connect this parser to a scanner!
	public parser(Lexer1 lex, ManejadorParser mp) {
		super(lex);
		this.mp = mp;
	}

        public void syntax_error(Symbol s) {
            //mp.printSintaxError("Â¡Error de sintaxis! -> "+ s.value +" Linea "+(s.left)+" columna "+(s.right) + "\n");
        }
:}

/* Terminals (tokens returned by the scanner). */
terminal String         BOOLEAN, CHAR, BYTE, INT, LONG, FLOAT, DOUBLE, STRING, NOT;
terminal String 		AND, OR, TRUE, FALSE, ARRAY, IF, ELSIF, ELSE, WHILE;
terminal String 		DO, FOR, PRINT, PRINTLN, COMMA, COLON, OPEN_BRK, CLOSE_BRK;
terminal String 		OPEN_SQR, CLOSE_SQR, SEMICOLON, ASSIGN, PLUS, MINUS, MULTI;
terminal String 		DIVISION, MODULE, LOWER_EQ, HIGHER_EQ, LOWER, HIGHER;
terminal String 		NOT_EQUAL, EQUAL, TEXT, NUM_INTEGER, NUM_DOUBLE, NUM_FLOAT, VARIABLE;
terminal String 		SCANS, SCANN, MAIN, RETURN, SEPARATOR, VOID;

non terminal Cuarteto 	instruction, decl, instructions, block;
non terminal Cuarteto 	programInstruction, programInstructionA, programInstructionB, mainInstruction, globalInstruction;
non terminal Cuarteto 	bodyInstruction, bodyInstructionA, bodySubprogram, instructionB;
non terminal String 	assign3, assign1;
non terminal Cuarteto 	assign, assign2, formalAssign, decl1, decls, declns, declns1;
non terminal Cuarteto 	arrayAssign, arrayPosition, arrayDim, arrayDim1;
non terminal Cuarteto 	array, assignA; 
non terminal LinkedList <Cuarteto> arrayDimen1, arrayDimen;
non terminal Cuarteto 	if, if1, ifA, elseifA, elseifAA, elseA, ifB, elseifB, elseifBB, elseB;
non terminal Cuarteto 	while, whileA;
non terminal String 	signo;
non terminal Cuarteto 	for, forA;
non terminal Cuarteto 	doWhile, doWhileA;
non terminal Cuarteto 	print, println, printA, printB, value, valueA, valueB;
non terminal String 	rel;
non terminal Tipo 	 	tipo;
non terminal Simbolo 	num, bool;
non terminal Cuarteto 	exp;
non terminal Cuarteto 	opNum, opNum2, ex, ex2;
non terminal Cuarteto 	opBol, b;
non terminal Cuarteto 	opRel, r, expRel, er;
non terminal Cuarteto 	scans, scann;
non terminal Cuarteto 	subprogram, parametros, parametrosA, parametro, rtrn;
non terminal Cuarteto 	subprogramCall, paramsProgram, paramsA;

precedence left 		ELSE;
precedence left 		ELSIF;
precedence left 		OR; 
precedence left 		AND;
precedence left 		NOT;
precedence left 		PLUS;
precedence left 		MINUS;
precedence left 		MULTI, DIVISION, MODULE;
precedence left 		EQUAL, NOT_EQUAL;
precedence left 		HIGHER_EQ, LOWER_EQ;
precedence left 		LOWER, HIGHER;
precedence left 		OPEN_BRK;

start with globalInstruction;

/* INICIO GRAMATICA DE -----3DIRECCIONES----- */

globalInstruction ::= 	bodyInstruction:e1 SEPARATOR mainInstruction:e2 {:mp.print(e1, e2);:}
						| SEPARATOR mainInstruction:e {:mp.print(null, e);:}
						| mainInstruction:e {:mp.print(null, e);:}
						;

mainInstruction ::= 	MAIN:e1 OPEN_BRK CLOSE_BRK {:mp.setSubprogramaActual(e1);mp.setGlobal(false);:} block:e2 {:mp.setGlobal(true);RESULT = e2;:}
						| MAIN:e OPEN_BRK CLOSE_BRK {::}
						| MAIN:e
						;

block ::= 				OPEN_SQR instructions:e CLOSE_SQR {:RESULT = e;:}
						| OPEN_SQR CLOSE_SQR {::}
						;

bodyInstruction ::= 	bodyInstruction:e1 bodyInstructionA:e2 {:RESULT = mp.getInstructions(e1, e2);:}
						| bodyInstructionA:e {:RESULT = e;:}
						;

bodyInstructionA ::=	subprogram:e {:RESULT = e;:}
						| instructionB:e {:RESULT = e;:}
						;

subprogram ::= 			tipo:e1 
						VARIABLE:e2 {:mp.setSubprogramaActual(e2); mp.setGlobal(false);:}
						parametrosA:e3
						bodySubprogram:e4 {:mp.verificateSubprogram();mp.setGlobal(true);RESULT = mp.getSubprograma(e2, e4);:}
						;

programInstruction ::= 	programInstruction:e1 programInstructionA:e2 {:RESULT = mp.getInstructions(e1, e2);:}
						| programInstructionA:e {:RESULT = e;:}
						;

programInstructionA ::= rtrn:e {:RESULT = e; mp.setSubprogramReturn(true);:}
						| programInstructionB:e {:RESULT = e;mp.addSubprogramInstruction(e);:}
						;

programInstructionB ::=	formalAssign:e {:RESULT = e;:}
						| arrayAssign:e {:RESULT = e;:}
						| if:e {::}
						| while:e {:RESULT = e;:}
						| for:e {:RESULT = e;:}
						| doWhile:e {:RESULT = e;:}
						| print:e {:RESULT = e;:}
						| println:e {:RESULT = e;:}
						| scans:e {::}
						| scann:e {::}
						;

subprogramCall ::= 		VARIABLE:e1 paramsA:e2 SEMICOLON {:RESULT = mp.getSubprogramCall(e1, e2, e1left, e1right);:}
						;

paramsA ::= 			OPEN_BRK CLOSE_BRK {:RESULT = null;:}
						| OPEN_BRK paramsProgram:e CLOSE_BRK {:RESULT = e;:}
						;

paramsProgram ::= 		paramsProgram:e1 COMMA opNum:e2 {:RESULT = mp.getComponentes(e1, e2);:}
						| opNum:e {:RESULT = mp.getComponente(e);:}
						;

rtrn ::=				RETURN opNum:e SEMICOLON {:RESULT = mp.getReturn(e, eleft, eright);:}
						;

parametrosA ::= 		OPEN_BRK CLOSE_BRK
						| OPEN_BRK parametros CLOSE_BRK
						;

parametros ::= 			parametros:e1 COMMA parametro:e2 
						| parametro:e 
						;

parametro ::= 			tipo:e1 VARIABLE:e2 
						;

bodySubprogram ::= 		OPEN_SQR declns:e1 SEPARATOR programInstruction:e2 CLOSE_SQR {:RESULT = mp.getInstructions(e1, e2);:}
						| OPEN_SQR declns:e CLOSE_SQR {:RESULT = e;:}
						| OPEN_SQR programInstruction:e CLOSE_SQR {:RESULT = e;:}
						| OPEN_SQR CLOSE_SQR {::}
						;

declns ::= 				declns:e1 declns1:e2 
						| declns1:e 
						;

declns1 ::=				decl:e {:RESULT = e;:}
						| array:e {::}
						;

instructions ::= 		instructions:e1 instruction:e2 {:RESULT = mp.getInstructions(e1,e2);:}
						| instruction:e {:RESULT = e;:}
						;

instructionB ::= 		decl:e {:RESULT = e;:}
						| formalAssign:e {:RESULT = e;:}
						| arrayAssign:e {:RESULT = e;:}
						| array:e {::}
						;

instruction ::=  		decl:e {:RESULT = e;:}
						| formalAssign:e {:RESULT = e;:}
						| arrayAssign:e {:RESULT = e;:}
						| array:e {::}
						| if {::}
						| while:e {:RESULT = e;:}
						| for:e {:RESULT = e;:}
						| doWhile:e {:RESULT = e;:}
						| print:e {:RESULT = e;:}
						| println:e {:RESULT = e;:}
						| scans:e {::}
						| scann:e {::}
						;

decl ::= 				tipo:e1 decls:e2 SEMICOLON {:RESULT = e2;:}
						;

decls ::= 				decls:e1 COMMA decl1:e2 {:RESULT = mp.getInstructions(e1, e2);:}
						| decl1:e {:RESULT = e;:}
						;

decl1 ::= 				assign2:e {:RESULT = e;:}
						| VARIABLE:e {::}
						;

assign2 ::= 			assign3:e1 exp:e2 {:RESULT = mp.asignByToken(e1,e2, e1left, e1right);:}
						;

assign3 ::= 			VARIABLE:e ASSIGN {:RESULT = e;:}
						;

arrayDim ::= 			arrayDim:e1 arrayDim1:e2 {:RESULT = mp.getComponentes(e1, e2);:}
						| arrayDim1:e {:RESULT = e;:}
						;

arrayDim1 ::= 			OPEN_SQR opNum:e CLOSE_SQR {:RESULT = mp.getPosition(e, eleft, eright);:}
						| error:e {:mp.printSintaxError("Error de array dimension");:}
						;

arrayDimen ::= 			arrayDimen:e1 arrayDimen1:e2 {::}
						| arrayDimen1:e {::}
						;

arrayDimen1 ::= 		OPEN_SQR opNum2:e CLOSE_SQR {::}
						| error:e {:mp.printSintaxError("Error de array dimension");:} CLOSE_SQR //OPEN_SQR NUM_INTEGER CLOSE_SQR
						;

array ::= 				ARRAY tipo:e1 arrayDimen:e2 assignA:e3 SEMICOLON {::}
						;

assignA ::= 			assignA:e1 COMMA VARIABLE:e2 {::}
						| VARIABLE:e {::}
						;

arrayAssign ::= 		arrayPosition:e1 ASSIGN exp:e2 SEMICOLON {:RESULT = mp.setArrayAsign(e1,e2);:}
						;

arrayPosition ::= 		VARIABLE:e1 arrayDim:e2 {:RESULT = mp.getArrayPosition(e1, e2, e1left, e1right);:}
						;

if ::= 					IF OPEN_BRK if1 CLOSE_BRK ifA {::}
						| IF OPEN_BRK if1 CLOSE_BRK ifB {::}
						;

if1 ::= 				opBol:e {:RESULT = e;:}
						;

ifA ::= 				instruction elseifA elseA {::}
						| instruction elseifA {::}
						| instruction elseA {::}
						| instruction {::}
						;

elseifA ::= 			elseifA elseifAA {::}
						| elseifAA {::}
						;

elseifAA ::= 			ELSIF OPEN_BRK opBol CLOSE_BRK instruction {::}
						;

elseA ::= 				ELSE instruction {::}
						;

ifB ::= 				block elseifB elseB {::}
						| block elseifB {::}
						| block elseB {::}
						| block {::}
						;

elseifB ::= 			elseifB elseifBB {::}
						| elseifBB {::}
						;

elseifBB ::= 			ELSIF:e1 OPEN_BRK opBol:e2 CLOSE_BRK block:e3 {::}
						;

elseB ::= 				ELSE:e1 block:e2 {::}
						;

while ::= 				WHILE:e1 OPEN_BRK opBol:e2 CLOSE_BRK whileA:e3 {:RESULT = mp.whileOperacion(e1,e2,e3);:}
						;

whileA ::= 				instruction:e {:RESULT = e;:}
						| block:e {:RESULT = e;:}
						;

doWhile ::= 			DO:e1 doWhileA:e3 WHILE OPEN_BRK opBol:e2 CLOSE_BRK {:RESULT = mp.doWhileOperacion(e1,e2,e3);:}
						;

doWhileA ::= 			instruction:e {:RESULT = e;:}
						| block:e {:RESULT = e;:}
						;

for ::= 				FOR OPEN_BRK assign:e1 COLON opBol:e2 COLON signo:e3 NUM_INTEGER:e4 CLOSE_BRK forA:e5 {:RESULT = mp.forOperacion(e1,e2,e3,e4,e5, e4left, e4right);:}
						;

forA ::= 				instruction:e {:RESULT = e;:}
						| block:e {:RESULT = e;:}
						;

scans ::= 				SCANS OPEN_SQR VARIABLE CLOSE_SQR SEMICOLON {::}
						| SCANS OPEN_SQR arrayPosition CLOSE_SQR SEMICOLON {::}
						;

scann ::= 				SCANN OPEN_SQR VARIABLE CLOSE_SQR SEMICOLON {::}
						| SCANN OPEN_SQR arrayPosition CLOSE_SQR SEMICOLON {::}
						;						

print ::= 				PRINT printA:e SEMICOLON {:RESULT = e;:}
						;

println ::= 			PRINTLN printB:e SEMICOLON {:RESULT = e;:}
						;

printA ::= 				OPEN_SQR valueA:e CLOSE_SQR {:RESULT = e;:}
						;

printB ::= 				OPEN_SQR valueB:e CLOSE_SQR {:RESULT = e;:}
						;

valueA ::= 				valueA:e1 COMMA value:e2 {:RESULT = mp.getPrint(e1,e2,ManejadorParser.PRINT);:}
						| value:e {:RESULT = mp.getSimplePrint(e,ManejadorParser.PRINT);:}
						;

valueB ::= 				valueB:e1 COMMA value:e2 {:RESULT = mp.getPrint(e1,e2,ManejadorParser.PRINTLN);:}
						| value:e {:RESULT = mp.getSimplePrint(e,ManejadorParser.PRINTLN);:}
						;

value ::= 				opNum:e {:RESULT = e;:}
						;

signo ::= 				PLUS:e {:RESULT = e;:}
						| MINUS:e {:RESULT = e;:}
						;

formalAssign ::= 		assign:e SEMICOLON {:RESULT = e;:}
						;

assign ::= 				assign1:e1 exp:e2 {:RESULT = mp.asignByToken(e1,e2, e1left, e1right);:}
						;

assign1 ::= 			VARIABLE:e ASSIGN {:RESULT = e;:}
						;

exp ::= 				opNum:e {:RESULT = e;:}
						;

opNum2 ::= 				ex2:e {:RESULT = mp.orderOpNum(e);:}
						;

ex2 ::= 				ex2:e1 MULTI:e2 ex2:e3 {:RESULT = mp.getMulti(e1, e2, e3);:}
						| ex2:e1 MINUS:e2 ex2:e3 {:RESULT = mp.getResta(e1, e2, e3);:}
						| ex2:e1 DIVISION:e2 ex2:e3 {:RESULT = mp.getDivision(e1, e2, e3);:}
						| ex2:e1 MODULE:e2 ex2:e3 {:RESULT = mp.getModulo(e1,e2, e3);:}
						| ex2:e1 PLUS:e2 ex2:e3 {:RESULT = mp.getSumaConcatenacion(e1, e2, e3);:}
						| OPEN_BRK ex2:e CLOSE_BRK {:RESULT = e;:}
						| num:e {:RESULT = mp.getCuartetoNum(e);:}
						| arrayPosition:e {:RESULT = e;:}
						| VARIABLE:e {:RESULT = mp.getVariable(e, eleft, eright);:}
						| TEXT:e {:RESULT = mp.getCuartetoString(e, eleft, eright);:}
						| bool:e {:RESULT = mp.getCuartetoBool(e);:}
						| subprogramCall:e {:RESULT = e;:}
						;

opNum ::= 				ex:e {:RESULT = mp.orderOpNum(e);:}
						;

ex ::= 					ex:e1 MULTI:e2 ex:e3 {:RESULT = mp.getMulti(e1, e2, e3);:}
						| ex:e1 MINUS:e2 ex:e3 {:RESULT = mp.getResta(e1, e2, e3);:}
						| ex:e1 DIVISION:e2 ex:e3 {:RESULT = mp.getDivision(e1, e2, e3);:}
						| ex:e1 MODULE:e2 ex:e3 {:RESULT = mp.getModulo(e1,e2, e3);:}
						| ex:e1 PLUS:e2 ex:e3 {:RESULT = mp.getSumaConcatenacion(e1, e2, e3);:}
						| OPEN_BRK ex:e CLOSE_BRK {:RESULT = e;:}
						| num:e {:RESULT = mp.getCuartetoNum(e);:}
						| arrayPosition:e {::}
						| VARIABLE:e {:RESULT = mp.getVariable(e, eleft, eright);:}
						| TEXT:e {:RESULT = mp.getCuartetoString(e, eleft, eright);:}
						| bool:e {:RESULT = mp.getCuartetoBool(e);:}
						| subprogramCall:e {::}
						;

num ::= 				NUM_INTEGER:e {:RESULT = mp.getSimbolEntero(e, eleft, eright);:}
						| NUM_FLOAT:e {:RESULT = mp.getSimbolFloat(e, eleft, eright);:}
						| NUM_DOUBLE:e {:RESULT = mp.getSimbolDouble(e, eleft, eright);:}
						;

opBol ::= 				b:e {:RESULT = e;:}
						;

b ::= 					b:e1 AND:e2 b:e3 {:RESULT = mp.getAnd(e1, e2, e3);:}
						| b:e1 OR:e2 b:e3 {:RESULT = mp.getOr(e1, e2, e3);:}
						| NOT:e1 b:e2 {:RESULT = mp.getNot(e1,e2);:}
						| OPEN_BRK b:e CLOSE_BRK {:RESULT = e;:}
						| opRel:e {:RESULT = e;:}
						| VARIABLE:e {:RESULT = mp.getVariableRel(e, eleft, eright);:}
						| bool:e {:RESULT = mp.getBool(e);:}
						| subprogramCall:e {:RESULT = e;:}
						;

opRel ::= 				r:e {:RESULT = e;:}
						;

r ::= 					expRel:e1 rel:e2 expRel:e3 {:RESULT = mp.getRelacion(e1, e2, e3);:}
						;

rel ::= 				HIGHER:e {:RESULT = e;:}
						| LOWER:e {:RESULT = e;:}
						| HIGHER_EQ:e {:RESULT = e;:}
						| LOWER_EQ:e {:RESULT = e;:}
						| NOT_EQUAL:e {:RESULT = e;:}
						| EQUAL:e {:RESULT = e;:}
						;

expRel ::= 				er:e {:RESULT = mp.orderOpNum(e);:}
						;

er ::= 					er:e1 MULTI:e2 er:e3 {:RESULT = mp.getMulti(e1, e2, e3);:}
						| er:e1 MINUS:e2 er:e3 {:RESULT = mp.getResta(e1, e2, e3);:}
						| er:e1 DIVISION:e2 er:e3 {:RESULT = mp.getDivision(e1, e2, e3);:}
						| er:e1 MODULE:e2 er:e3 {:RESULT = mp.getModulo(e1,e2, e3);:}
						| er:e1 PLUS:e2 er:e3 {:RESULT = mp.getSumaConcatenacion(e1, e2, e3);:}
						| num:e {:RESULT = mp.getCuartetoNum(e);:}
						| arrayPosition:e {:RESULT = e;:}
						| VARIABLE:e {:RESULT = mp.getVariable(e, eleft, eright);:}
						| subprogramCall:e {:RESULT = e;:}
						;

bool ::= 				TRUE:e {:RESULT = mp.getSimbolBoolean(e, eleft, eright);:}
						| FALSE:e {:RESULT = mp.getSimbolBoolean(e, eleft, eright);:}
						;

tipo ::= 				BOOLEAN:e {:RESULT = mp.getTipoByKey(e);:}
						| CHAR:e {:RESULT = mp.getTipoByKey(e);:}
						| BYTE:e {:RESULT = mp.getTipoByKey(e);:}
						| INT:e {:RESULT = mp.getTipoByKey(e);:}
						| LONG:e {:RESULT = mp.getTipoByKey(e);:}
						| FLOAT:e {:RESULT = mp.getTipoByKey(e);:}
						| DOUBLE:e {:RESULT = mp.getTipoByKey(e);:}
						| STRING:e {:RESULT = mp.getTipoByKey(e);:}
						| VOID:e {:RESULT = mp.getTipoByKey(e);:}
						;

/*
java -jar ../lib/java-cup-11b.jar AnalizadorSintactico1.cup
cp parser.java ../src/codigo3d/backend/analizadores/parser.java
*/

/*
x <- 20;
y <- 30;
int x, y;
int x (int a, int b)[
int d;
%%%
WHILE(d > x)[
x <- 20;
]
return 10;
]
%%%
MAIN()[

]
*/